<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Common functions used across pallet projects" name="description" /><style type="text/css"></style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css"></style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;}h1{font-size:20px;margin-top:0;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript"></script><script type="text/javascript"></script><script type="text/javascript"></script><script type="text/javascript"></script><script type="text/javascript"></script><title>pallet-common -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">pallet-common</h1><h2 class="project-version">0.1.1-SNAPSHOT</h2><br /><p>Common functions used across pallet projects</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.1</td></tr><tr><td class="dep-name">org.clojure/tools.logging</td><td class="dotted"><hr /></td><td class="dep-version">0.1.2</td></tr><tr><td class="dep-name">log4j/log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.2.14</td></tr><tr><td class="dep-name">org.slf4j/slf4j-api</td><td class="dotted"><hr /></td><td class="dep-version">1.6.1</td></tr><tr><td class="dep-name">ch.qos.logback/logback-core</td><td class="dotted"><hr /></td><td class="dep-version">0.9.28</td></tr><tr><td class="dep-name">ch.qos.logback/logback-classic</td><td class="dotted"><hr /></td><td class="dep-version">0.9.28</td></tr><tr><td class="dep-name">jline/jline</td><td class="dotted"><hr /></td><td class="dep-version">0.9.94</td></tr><tr><td class="dep-name">swank-clojure/swank-clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.1</td></tr><tr><td class="dep-name">autodoc/autodoc</td><td class="dotted"><hr /></td><td class="dep-version">0.7.1</td></tr><tr><td class="dep-name">marginalia/marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.6.0</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#pallet.common.def">pallet.common.def</a></li><li><a href="#pallet.common.deprecate">pallet.common.deprecate</a></li><li><a href="#pallet.common.filesystem">pallet.common.filesystem</a></li><li><a href="#pallet.common.logging.log4j">pallet.common.logging.log4j</a></li><li><a href="#pallet.common.logging.logback">pallet.common.logging.logback</a></li><li><a href="#pallet.common.logging.logutils">pallet.common.logging.logutils</a></li><li><a href="#pallet.common.logging.slf4j">pallet.common.logging.slf4j</a></li><li><a href="#pallet.common.resource">pallet.common.resource</a></li><li><a href="#pallet.common.shell">pallet.common.shell</a></li><li><a href="#pallet.common.string">pallet.common.string</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.def" name="pallet.common.def"><h1 class="project-name">pallet.common.def</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Helpers for writing def macros</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.def)</pre></tr><tr><td class="docs"><p>To be used in macro definitions.
   Handles optional docstrings and attribute maps for a name to be defined
   in a list of macro arguments. If the first macro argument is a string
   it is added as a docstring to name and removed from the macro argument
   list. If afterwards the first macro argument is a map, its entries are
   added to the name's metadata map and the map is removed from the
   macro argument list. The return value is a vector containing the name
   with its extended metadata map and the list of unprocessed macro
   arguments.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn name-with-attributes
  [name macro-args]
  (let [[docstring macro-args] (if (string? (first macro-args))
                                 [(first macro-args) (next macro-args)]
                                 [nil macro-args])
    [attr macro-args]          (if (map? (first macro-args))
                                 [(first macro-args) (next macro-args)]
                                 [{} macro-args])
    attr                       (if docstring
                                 (assoc attr :doc docstring)
                                 attr)
    attr                       (if (meta name)
                                 (conj (meta name) attr)
                                 attr)]
    [(with-meta name attr) macro-args]))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.deprecate" name="pallet.common.deprecate"><h1 class="project-name">pallet.common.deprecate</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Deprecation forms</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.deprecate
  (:require
   [clojure.tools.logging :as logging]))</pre></tr><tr><td class="docs"><p>Find the call site of a function. A macro so we don't create extra frames.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro find-caller-from-stack
  ([] `(find-caller-from-stack 4))
  ([frame-depth]
     `(let [frame# (nth (.. (Thread/currentThread) getStackTrace) ~frame-depth)]
        [(.getFileName frame#) (.getLineNumber frame#)])))</pre></tr><tr><td class="docs"><p>Log a deprecation warning</p>
</td><td class="codes" /><pre class="brush: clojure">(defn warn
  ([message]
     (logging/warnf &quot;DEPRECATED %s&quot; message))
  ([file message]
     (logging/warnf &quot;DEPRECATED [%s] %s&quot; (or file &quot;unknown&quot;) message))
  ([file line message]
     (logging/warnf
      &quot;DEPRECATED [%s:%s] %s&quot; (or file &quot;unknown&quot;) (or line &quot;unknown&quot;) message)))</pre></tr><tr><td class="docs"><p>Generates a deprecated warning for a macro, allowing the source file and
   line to be captured</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro deprecated-macro
  [form message]
  `(warn ~(:file (meta form) *file*) ~(:line (meta form)) ~message))</pre></tr><tr><td class="docs"><p>Generates a deprecated warning, locating file and line from the call stack.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn deprecated
  [message]
  (let [[file line] (find-caller-from-stack)]
    (warn file line message)))</pre></tr><tr><td class="docs"><p>Generates a deprecated message for renaming a function</p>
</td><td class="codes" /><pre class="brush: clojure">(defn rename
  [from to]
  (format &quot;%s is deprecated, use %s&quot; (pr-str from) (pr-str to)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-no-warn
  [f-name to-ns]
  `(def ~f-name ~(symbol (name to-ns) (name f-name))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-fn-warn
  [f-name ns]
  (let [argv (gensym &quot;argv&quot;)]
    `(defmacro ~f-name [~'&amp; ~argv]
       `(do
          (deprecated-macro
           ~~'&amp;form
           (deprecate-rename
            ~(list 'quote (symbol (name (ns-name *ns*)) (name '~f-name)))
            ~'~(list 'quote (symbol (name (ns-name ns)) (name f-name)))))
          ~~(list
             `list*
             (list 'quote (symbol (name ns) (name f-name)))
             argv)))))
(defmacro forward-fn-no-warn
  [f-name ns]
  `(forward-no-warn ~f-name ~ns))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-fn
  [f-name ns]
  (if (System/getProperty &quot;pallet.warn-on-resource-use&quot;)
    `(forward-fn-warn ~f-name ~ns)
    `(forward-fn-no-warn ~f-name ~ns)))</pre></tr><tr><td class="docs"><p>Forward syms to ns</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-fns
  [ns &amp; fns]
  `(do ~@(for [f fns] `(forward-fn ~f ~ns))))</pre></tr><tr><td class="docs"><p>Forward syms to ns</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-vars
  [ns &amp; syms]
  `(do ~@(for [sym syms] `(forward-no-warn ~sym ~ns))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.filesystem" name="pallet.common.filesystem"><h1 class="project-name">pallet.common.filesystem</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Filesystem functions</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.filesystem
  (:require
   [clojure.java.io :as io]))</pre></tr><tr><td class="docs"><p>Create a block where <code>varname</code> is a temporary <code>File</code> containing <code>content</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-temp-file
  [[varname &amp; [content]] &amp; body]
  `(let [~varname (java.io.File/createTempFile &quot;stevedore&quot;, &quot;.tmp&quot;)]
     (when-let [content# ~content]
       (io/copy content# ~varname))
     (let [rv# (do ~@body)]
       (.delete ~varname)
       rv#)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.logging.log4j" name="pallet.common.logging.log4j"><h1 class="project-name">pallet.common.logging.log4j</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for manipulating log4j</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.logging.log4j)</pre></tr><tr><td class="docs"><p>Configure log4j using specified configuration file path.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn configure-from-path
  [path]
  (org.apache.log4j.xml.DOMConfigurator/configure
   (java.net.URL. path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def log-priorities
  {:warn org.apache.log4j.Priority/WARN
   :debug org.apache.log4j.Priority/DEBUG
   :fatal org.apache.log4j.Priority/FATAL
   :info org.apache.log4j.Priority/INFO
   :error org.apache.log4j.Priority/ERROR})</pre></tr><tr><td class="docs"><p>Get the appender with the specified name</p>
</td><td class="codes" /><pre class="brush: clojure">(defn appender
  [appender-name]
  (.. (org.apache.log4j.Logger/getRootLogger) (getAppender appender-name)))</pre></tr><tr><td class="docs"><p>A scope for logging with an appender at the specified threshold</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-appender-threshold
  [[level &amp; [appender-name]] &amp; body]
  `(let [appender-name# (or ~appender-name &quot;console&quot;)]
     (if-let [appender# (appender appender-name#)]
       (let [threshold# (.getThreshold appender#)]
         (try
           (.setThreshold
            appender# (~level log-priorities org.apache.log4j.Priority/WARN))
           ~@body
           (finally
            (.setThreshold appender# threshold#))))
       (throw
        (RuntimeException.
         (format &quot;Could not find appender \&quot;%s\&quot;&quot; appender-name#))))))</pre></tr><tr><td class="docs"><p>A fixture to set the logging level of a specified appender</p>
</td><td class="codes" /><pre class="brush: clojure">(defn logging-threshold-fixture
  ([] (logging-threshold-fixture :error &quot;console&quot;))
  ([level] (logging-threshold-fixture level &quot;console&quot;))
  ([level appender-name]
     (fn [f]
       (with-appender-threshold [level appender-name]
         (f)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.logging.logback" name="pallet.common.logging.logback"><h1 class="project-name">pallet.common.logging.logback</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for manipulating logback</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.logging.logback
  (:require
   [clojure.tools.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def log-priorities
  {:warn ch.qos.logback.classic.Level/WARN
   :debug ch.qos.logback.classic.Level/DEBUG
   :fatal ch.qos.logback.classic.Level/ERROR
   :info ch.qos.logback.classic.Level/INFO
   :error ch.qos.logback.classic.Level/ERROR
   :off ch.qos.logback.classic.Level/OFF
   :all ch.qos.logback.classic.Level/ALL})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def root-logger-name org.slf4j.Logger/ROOT_LOGGER_NAME)</pre></tr><tr><td class="docs"><p>Get the logger with the specified name</p>
</td><td class="codes" /><pre class="brush: clojure">(defn logger
  ([] (logger root-logger-name))
  ([^String logger-name]
     (org.slf4j.LoggerFactory/getLogger logger-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn set-filters [appender filters]
  (.clearAllFilters appender)
  (doseq [filter filters]
    (.addFilter appender filter)))</pre></tr><tr><td class="docs"><p>A scope for logging with a logger at the specified level</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-logger-level
  [[level &amp; [appender-name logger-name]] &amp; body]
  `(let [logger-name# ~logger-name
         appender-name# (or ~appender-name &quot;CONSOLE&quot;)]
     (if-let [logger# (logger (or logger-name# root-logger-name))]
       (if-let [appender# (.getAppender logger# appender-name#)]
         (let [filters# (.getCopyOfAttachedFiltersList appender#)
               filter# (ch.qos.logback.classic.filter.LevelFilter.)]
           (try
             (.addFilter appender# filter#)
             (doto filter#
               (.setOnMatch ch.qos.logback.core.spi.FilterReply/ACCEPT)
               (.setOnMismatch ch.qos.logback.core.spi.FilterReply/DENY)
               (.setLevel
                (~level log-priorities ch.qos.logback.classic.Level/WARN))
               (.start))
             ~@body
             (.stop filter#)
             (finally
              (set-filters appender# filters#))))
         (throw
          (RuntimeException.
           (format &quot;Could not find appender \&quot;%s\&quot;&quot; appender-name#))))
       (throw
          (RuntimeException.
           (format &quot;Could not find logger \&quot;%s\&quot;&quot; logger-name#))))))</pre></tr><tr><td class="docs"><p>A fixture to set the logging level of a specified logger</p>
</td><td class="codes" /><pre class="brush: clojure">(defn logging-threshold-fixture
  ([]
     (logging-threshold-fixture :error &quot;CONSOLE&quot; root-logger-name))
  ([level]
     (logging-threshold-fixture level &quot;CONSOLE&quot; root-logger-name))
  ([level appender-name]
     (logging-threshold-fixture level appender-name root-logger-name))
  ([level appender-name logger-name]
     (fn [f]
       (with-logger-level [level appender-name logger-name]
         (f)))))</pre></tr><tr><td class="docs"><p>Print logback status when configured under slf4j</p>
</td><td class="codes" /><pre class="brush: clojure">(defn slf4j-logback-status
  []
  (ch.qos.logback.core.util.StatusPrinter/print
   (org.slf4j.LoggerFactory/getILoggerFactory)))</pre></tr><tr><td class="docs"><p>A scope for logging with a logger at the specified level</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-log-to-string
  [[&amp; [appender-name logger-name]] &amp; body]
  `(let [logger-name# ~logger-name
         appender-name# (or ~appender-name &quot;CONSOLE&quot;)
         out# System/out]
     (if-let [logger# (logger (or logger-name# root-logger-name))]
       (if-let [appender# (.getAppender logger# appender-name#)]
         (try
           (let [s# (java.io.ByteArrayOutputStream.)]
             (System/setOut (java.io.PrintStream. s#))
             (.setTarget appender# &quot;System.out&quot;)
             ~@body
             (str s#))
           (finally
            (System/setOut out#)
            (.setTarget appender# &quot;System.out&quot;)))
         (throw
          (RuntimeException.
           (format &quot;Could not find appender \&quot;%s\&quot;&quot; appender-name#))))
       (throw
          (RuntimeException.
           (format &quot;Could not find logger \&quot;%s\&quot;&quot; logger-name#))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.logging.logutils" name="pallet.common.logging.logutils"><h1 class="project-name">pallet.common.logging.logutils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities for logging</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.logging.logutils
  (:require
   [clojure.tools.logging :as logging]
   [clojure.stacktrace :as stacktrace]))</pre></tr><tr><td class="docs"><p>A null logger
Suppresses all logging.  Can be useful to quiet test cases.</p>
</td><td class="codes" /><pre class="brush: clojure">(deftype NullLog
    []
  clojure.tools.logging.Log
  (impl-enabled? [log level] false)
  (impl-write! [log level throwable message]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def null-log (delay (NullLog.)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype NullLogger
    []
  clojure.tools.logging.LogFactory
  (impl-name [factory] &quot;null logger&quot;)
  (impl-get-log [factory log-ns] @null-log))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def null-logger (delay (NullLogger.)))</pre></tr><tr><td class="docs"><p>A stdout logger
Logs everyting to stdout.  Can be useful to test logging.</p>
</td><td class="codes" /><pre class="brush: clojure">(deftype StdoutLog
    []
  clojure.tools.logging.Log
  (impl-enabled? [log level] true)
  (impl-write! [log level throwable message]
    (println (name level) message)
    (when throwable
      (stacktrace/print-stack-trace
       (stacktrace/root-cause throwable)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def stdout-log (delay (StdoutLog.)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype StdoutLogger
    []
  clojure.tools.logging.LogFactory
  (impl-name [factory] &quot;stdout logger&quot;)
  (impl-get-log [factory log-ns] @stdout-log))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def stdout-logger (delay (StdoutLogger.)))</pre></tr><tr><td class="docs"><p>Send log messages to stdout for inspection</p>

<p>Macros to use specific logging implementations in a given scope</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro logging-to-stdout
  [&amp; forms]
  `(binding [clojure.tools.logging/*log-factory* @stdout-logger]
     ~@forms))</pre></tr><tr><td class="docs"><p>Prevent log messages to reduce test log noise</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro suppress-logging
  [&amp; forms]
  `(binding [clojure.tools.logging/*log-factory* @null-logger]
     ~@forms))</pre></tr><tr><td class="docs"><p>Specify the logging context for a given <code>body</code>. <code>bindings</code> is a vector of
   keyword value pairs to be set on the Mapped Diagnostic Context. If the
   current logger doesn't support contexts, then the body is just wrapped in a
   <code>do</code>. slf4j is the only supported logger at present.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-context
  [bindings &amp; body]
  (try
    (require 'pallet.common.logging.slf4j)
    `(pallet.common.logging.slf4j/with-context [~@bindings]
       ~@body)
    (catch Exception _
      `(do ~@body))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-threshold
  [[level &amp; [appender-name logger-name]] &amp; body]
  (try
       (require 'pallet.common.logging.logback)
       `(pallet.common.logging.logback/with-logger-level
          [~level ~appender-name ~logger-name] ~@body)
       (catch Exception _
         (try
           (require 'pallet.common.logging.log4j)
           `(pallet.common.logging.log4j/with-appender-threshold
              [~level ~appender-name] ~@body)
           (catch Exception _
             (fn [f] (f)))))))</pre></tr><tr><td class="docs"><p>A fixture to set the logging level of a specified logger</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro logging-threshold-fixture
  ([level appender-name logger-name]
     (try
       (require 'pallet.common.logging.logback)
       `(pallet.common.logging.logback/logging-threshold-fixture
         ~level ~appender-name ~logger-name)
       (catch Exception _
         (try
           (require 'pallet.common.logging.log4j)
           `(pallet.common.logging.log4j/logging-threshold-fixture
             ~level ~appender-name ~logger-name)
           (catch Exception _
             (fn [f] (f)))))))
  ([level appender-name] `(logging-threshold-fixture ~level appender-name nil))
  ([level] `(logging-threshold-fixture ~level nil nil))
  ([] `(logging-threshold-fixture :error nil nil)))</pre></tr><tr><td class="docs"><p>Target the logger for an output string.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-log-to-string
  [[&amp; args] &amp; body]
  (try
    (require 'pallet.common.logging.logback)
    `(pallet.common.logging.logback/with-log-to-string [~@args] ~@body)
    (catch Exception _
      `(with-out-str ~@body))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.logging.slf4j" name="pallet.common.logging.slf4j"><h1 class="project-name">pallet.common.logging.slf4j</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for manipulating slf4j</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.logging.slf4j
  (:import
   (org.slf4j Logger LoggerFactory MDC)))</pre></tr><tr><td class="docs"><p>Mapped Diagnostic Context (MDC)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn put-context [key val]
  (MDC/put (name key) (str val)))</pre></tr><tr><td class="docs"><p>Specify the logging context for a given body. <code>bindings</code> is a vector of
   keyword value pairs to be set on the Mapped Diagnostic Context.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-context
  [bindings &amp; body]
  `(let [current-context-map# (MDC/getCopyOfContextMap)]
     (try
       (doseq [[k# v#] (partition 2 ~bindings)]
         (put-context k# v#))
       ~@body
       (finally
        (if current-context-map#
          (MDC/setContextMap current-context-map#)
          (MDC/clear))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.resource" name="pallet.common.resource"><h1 class="project-name">pallet.common.resource</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Forms for manipulating (classpath) resources</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.resource
  (:refer-clojure :exclude [slurp]))</pre></tr><tr><td class="docs"><p>Reads the resource named by name using the encoding enc into a string
   and returns it.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn slurp
  ([name] (slurp name (.name (java.nio.charset.Charset/defaultCharset))))
  ([#^String name #^String enc]
     (let [stream (-&gt; (.getContextClassLoader (Thread/currentThread))
                      (.getResourceAsStream name)
                      (java.io.InputStreamReader.))]
       (when stream
         (with-open [stream stream]
           (clojure.core/slurp stream))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.shell" name="pallet.common.shell"><h1 class="project-name">pallet.common.shell</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Shell functions</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.shell
  (:require
   [pallet.common.filesystem :as filesystem]
   [clojure.java.shell :as shell]))</pre></tr><tr><td class="docs"><p>Launch a system process, return a map containing the exit code, standard
  output and standard error of the process.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn system
  [cmd]
  (apply shell/sh (.split cmd &quot; &quot;)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn bash [cmds]
  (filesystem/with-temp-file [file cmds]
    (shell/sh &quot;/usr/bin/env&quot; &quot;bash&quot; (.getPath file))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.common.string" name="pallet.common.string"><h1 class="project-name">pallet.common.string</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>String utilities</p>

<p>   Follows design notes from clojure.string</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.common.string
  (:require
    [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>The one index version drops first n characters from s.  Returns an empty
   string if n is greater than the length of s.</p>

<p>   The two index version returns a substring between the two indices.</p>

<pre><code>   (substring "test" 1) =&gt; "est"
   (substring "test" 1 3) =&gt; "es"
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn ^String substring
  ([^CharSequence s n]
     (if (&lt; (count s) n)
       &quot;&quot;
       (.substring s n)))
  ([^CharSequence s n m]
     (if (&lt; (count s) n)
       &quot;&quot;
       (.substring s n (min m (count s))))))</pre></tr><tr><td class="docs"><p>Add quotes to the argument s as a string</p>
</td><td class="codes" /><pre class="brush: clojure">(defn ^String quoted
  [s]
  (str &quot;\&quot;&quot; s &quot;\&quot;&quot;))</pre></tr><tr><td class="docs"><p>Replace all occurances of - with _</p>
</td><td class="codes" /><pre class="brush: clojure">(defn ^String underscore
  [^CharSequence s]
  (string/replace s \- \_))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_pallet.common.def">pallet.common.def</li><li class="floating-toc-li" id="floating-toc_pallet.common.deprecate">pallet.common.deprecate</li><li class="floating-toc-li" id="floating-toc_pallet.common.filesystem">pallet.common.filesystem</li><li class="floating-toc-li" id="floating-toc_pallet.common.logging.log4j">pallet.common.logging.log4j</li><li class="floating-toc-li" id="floating-toc_pallet.common.logging.logback">pallet.common.logging.logback</li><li class="floating-toc-li" id="floating-toc_pallet.common.logging.logutils">pallet.common.logging.logutils</li><li class="floating-toc-li" id="floating-toc_pallet.common.logging.slf4j">pallet.common.logging.slf4j</li><li class="floating-toc-li" id="floating-toc_pallet.common.resource">pallet.common.resource</li><li class="floating-toc-li" id="floating-toc_pallet.common.shell">pallet.common.shell</li><li class="floating-toc-li" id="floating-toc_pallet.common.string">pallet.common.string</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>